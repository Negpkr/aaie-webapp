// Formatting utilities for AAIE application

import { format, formatDistanceToNow, isValid, parseISO } from 'date-fns';

// Date formatting
export const formatters = {
  // Date and time formatting
  formatDate: (date: string | Date): string => {
    try {
      const dateObj = typeof date === 'string' ? parseISO(date) : date;
      if (!isValid(dateObj)) return 'Invalid date';
      return format(dateObj, 'PPP'); // Jan 1, 2024
    } catch {
      return 'Invalid date';
    }
  },

  formatDateTime: (date: string | Date): string => {
    try {
      const dateObj = typeof date === 'string' ? parseISO(date) : date;
      if (!isValid(dateObj)) return 'Invalid date';
      return format(dateObj, 'PPp'); // Jan 1, 2024 at 12:00 PM
    } catch {
      return 'Invalid date';
    }
  },

  formatTimeAgo: (date: string | Date): string => {
    try {
      const dateObj = typeof date === 'string' ? parseISO(date) : date;
      if (!isValid(dateObj)) return 'Unknown';
      return formatDistanceToNow(dateObj, { addSuffix: true });
    } catch {
      return 'Unknown';
    }
  },

  formatDueDate: (date: string | Date): { text: string; isOverdue: boolean; isUrgent: boolean } => {
    try {
      const dateObj = typeof date === 'string' ? parseISO(date) : date;
      if (!isValid(dateObj)) return { text: 'Invalid date', isOverdue: false, isUrgent: false };
      
      const now = new Date();
      const isOverdue = dateObj < now;
      const hoursDiff = (dateObj.getTime() - now.getTime()) / (1000 * 60 * 60);
      const isUrgent = hoursDiff > 0 && hoursDiff <= 24; // Due within 24 hours
      
      return {
        text: formatDistanceToNow(dateObj, { addSuffix: true }),
        isOverdue,
        isUrgent,
      };
    } catch {
      return { text: 'Invalid date', isOverdue: false, isUrgent: false };
    }
  },

  // Score and percentage formatting
  formatScore: (score: number, maxScore: number = 5): string => {
    if (score < 0 || score > maxScore) return 'Invalid score';
    return `${score}/${maxScore}`;
  },

  formatPercentage: (score: number, maxScore: number = 5): string => {
    if (score < 0 || score > maxScore) return 'Invalid score';
    const percentage = Math.round((score / maxScore) * 100);
    return `${percentage}%`;
  },

  formatConfidence: (confidence: number): string => {
    if (confidence < 0 || confidence > 1) return 'Invalid confidence';
    return `${Math.round(confidence * 100)}%`;
  },

  // Text formatting
  formatName: (name: string): string => {
    return name
      .trim()
      .toLowerCase()
      .replace(/\b\w/g, (char) => char.toUpperCase());
  },

  formatEmail: (email: string): string => {
    return email.trim().toLowerCase();
  },

  truncateText: (text: string, maxLength: number = 100): string => {
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength).trim() + '...';
  },

  // Classification formatting
  formatClassification: (classification: 'Human' | 'AI' | 'Hybrid'): {
    label: string;
    variant: 'default' | 'secondary' | 'destructive' | 'outline';
    description: string;
  } => {
    switch (classification) {
      case 'Human':
        return {
          label: 'Human-Generated',
          variant: 'default',
          description: 'Content appears to be entirely human-written',
        };
      case 'AI':
        return {
          label: 'AI-Generated',
          variant: 'destructive',
          description: 'Content appears to be generated by AI',
        };
      case 'Hybrid':
        return {
          label: 'Human-AI Hybrid',
          variant: 'secondary',
          description: 'Content appears to be a mix of human and AI-generated text',
        };
      default:
        return {
          label: 'Unknown',
          variant: 'outline',
          description: 'Classification not available',
        };
    }
  },

  // File size formatting
  formatFileSize: (bytes: number): string => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  },

  // Status formatting
  formatStatus: (status: 'pending' | 'evaluated' | 'reviewed'): {
    label: string;
    variant: 'default' | 'secondary' | 'destructive' | 'outline';
    description: string;
  } => {
    switch (status) {
      case 'pending':
        return {
          label: 'Pending',
          variant: 'outline',
          description: 'Awaiting evaluation',
        };
      case 'evaluated':
        return {
          label: 'Evaluated',
          variant: 'secondary',
          description: 'AI evaluation completed',
        };
      case 'reviewed':
        return {
          label: 'Reviewed',
          variant: 'default',
          description: 'Reviewed by educator',
        };
      default:
        return {
          label: 'Unknown',
          variant: 'outline',
          description: 'Status not available',
        };
    }
  },

  // Grade calculation
  calculateOverallGrade: (rubricScores: Record<string, number>): {
    average: number;
    letter: string;
    description: string;
  } => {
    const scores = Object.values(rubricScores);
    const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    
    let letter: string;
    let description: string;
    
    if (average >= 4.5) {
      letter = 'A';
      description = 'Excellent';
    } else if (average >= 3.5) {
      letter = 'B';
      description = 'Good';
    } else if (average >= 2.5) {
      letter = 'C';
      description = 'Satisfactory';
    } else if (average >= 1.5) {
      letter = 'D';
      description = 'Needs Improvement';
    } else {
      letter = 'F';
      description = 'Unsatisfactory';
    }
    
    return { average, letter, description };
  },
};